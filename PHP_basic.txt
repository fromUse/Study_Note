-----------------------------------------------------------------------------------
####重点[ 比较php与java、c等语法的差异 ]

##声明变量用‘$’开头
#	例:$bl; [ 语句以英文分号‘;’结束 ]

##注意事项
#	php可以忽略数据类型 例:$l = 10;$bl = "字符串";$bl = 1.00;$bl = new [ 类名 ];

##php变量的引用
#	echo  $bl;

##php常量
#	const	BL = [ values ];	php5.3以后有效
#	define("变量名","变量值");  这是一个函数php5.3以前适用

##常量的引用
#	echo 变量名; [ 常量名前不用加 ‘$’ ]


-----------------------------------------------------------------------------------


##php字符串
#	在php在字符串可以用双引号、单引号包裹字符串
#	例 “字符串内容” 或者 ‘字符串内容’

##字符串的连接
# 用英文的的点 ‘.’ 进行连接
# 例 “字符串1”.“字符串2”   [ 结果等于 “字符串1字符串2” ]

##字符串注意事项
# 其中单引号‘’ 包裹内容时和 java、c 等用法一样
# 其中双引号“” 包裹内容时和 java、c 有部分不一样 [ 可以在字符内引用变量 ]
# 双引号优势:   echo "字符串内容 $bl " [ $bl 就是引用的变量 ]



-----------------------------------------------------------------------------------

##php比较运算符 [ 此处只举例与Java、C有差异的运算符 ]
#	等于 ‘ == ’  例$bl == $bl2; [ 数值相等 数据类型不一定相等 ]
#	全等 ‘ === ’  例 $bl === $bl2 [ 必须同时满足 数值、数据类型。都相等时才是全等 ]
#	不等 ‘ <> ’   例 $a <> $b [ 效果与 $a != $b 一样 ]
#	非全等 ‘ !=== ’ 例 $a !=== $b [ $a、$b数值不等, 或者$a、$b数据类型不等 ]


-----------------------------------------------------------------------------------

##php数组 [ 索引数组,关联数组 ] 实际是一个Map集合 
# 索引数组和 java / c 概念一样
# 关联数组 和java的 Map 概念一样 [ 键值对 ]
# php声明数组通过 array() 来声明数组  < array()并不是一个函数 是php的语言结构 >,数组没有数组长度的问题 [ 无大小限制，内部数据结构用链表实现 ]
#
# $arr = array(val0,val1,val2); [ 索引从0开始 ]

# 关联数组自定义key,键与值之间用 =>
# $arr = array( 
#				'key1' => val0,
#       'key2' => val1,
#       'key3' => val2
#      );   

# 引用数组一个值$arr['0'];
# 引用数组一个值$arr['key2'];
-----------------------------------------------------------------------------------


##php控制流程
# if ,if else,if elseif,switch,while,for, 都一样[ 循环多了一个exit 终止当前循环 ]
# foreach($arr as $key=>$value){
#	 循环体		
# }

# $arr为被遍历的数组,$key为每一项元素的key值,$value为每一项元素的值


# each() 获取数组的一个元素，并包装成一个新全新的数组，原来的数组指针往后移动一位，
  # 和java的迭代器概念一样 可以实现遍历自定义key数组
  
-----------------------------------------------------------------------------------



##检查某个对象[ 实例 ]是否是某个类的的实例 关键字 [ instanceof ]
# [ instanceof ]是针对 面向对象 编程的实例的检查
# 例：class  A ,class B,其中B extents A 时,
# 类A B,的实例 $a = new A,$b = new B,
# echo ( a instanreof A ); 结果是TRUE,
# echo ( b instanreof B ); 结果是TRUE,
# echo ( b instanceof A ); 结果是TRUE;



-----------------------------------------------------------------------------------



##php[ 自定义 ] 函数 [ 面向过程 思想的叫函数 ]
# 创建自定义函数格式  function [ fun_name ](data_type [arg_name ]，，，){  函数体 }
# 例 : function fun($arg){
#			echo $arg;
#
#    }
##注意事项
# 参数可以是一个变量的 [ 引用 & ][ 指针 ]
#	参数[ arg ] 的数据类型[ data_type ]可以省略 直接写变量
# 参数可以写默认值 或者木有参数 [ 默认参数value只能是常量 ]，
# 默认参数 必须居于 非默认参数 的右边[ 参数的最右边 ]
#	默认值 function fun($arg = [ values || null ]，，，){
#		函数体
#	}
# 当有函数参数 有默认值时 调用函数 可以不填参数!!!!   如调用上文 :fun()；


##php特性 可变函数 [ 函数名 可以用某个 变量表示 ]
# 例 调用上文fun函数 fun([ values ]) 与 $func = "fun"; $func([ values ]);效果一样
#	面向对象 里面的类 [ 方法 ] 同样适用

-----------------------------------------------------------------------------------

##面向对象专题
##	构造方法 __construct(); [ new 实例时 自动调用 ]
##	析构方法 __dedtruct();  [ 实例被干掉时 自动调用]

##成员变量、成员方法 的调用通过‘ -> ’进行调用
#   例$a = new A; a->[ 变量名 ]、a->[ 方法名 ]();

## 静态成员变量、静态成员方法 通过双冒号 ‘::’
# 类内部时: self::[ 静态变量名 ]，self::[ 静态方法名 ]();
# 类外部时 class_name::[ 静态变量名 ],class_name::[ 静态方法名 ]();


##php魔术方法 [ 针对  某某不存在 弥补出现程序错误 ] 或者 [ 针对特殊需求时 重载以下方法 来 实现特殊功能 且方法是系统自动调用 ]
#	__toString() [ 和java 用法一样 ]
#	__invoke() [ 当以 对象名() 的形式调用方法时  自动调用此方法 ]
#	__call()	[ 当对象调用一个不存在的方法时 自动调用此方法 ]
#	__callStatic()	[ 当对象调用 不存在的静态方法时 默认自动调用此方法 ]
#	__get() [ 当调用一个不存在的 成员变量 自动调用此方法 ]
#	__set()	[ 当给一个 不存在的 成员变量 赋值时 自动调用此方法 ]
#	__isset() [ 判断某个成员变量是否存在isset($obj->$bl) 自动调用此方法 ]
#	__unset() [ 删除某个不存在的成员变量时 自动调用此方法 ]
#	__sleep()
#	__wakeup()
#	__set_state()
#	__clone() [ 默认时 相当于new出一个新的实例 并把成员变量的相关数值 复制过去 ] [ 当需要复制部分数据 或者 自定义数据 可以重载此方法 ]


	------------------------------------------- 正则 ----------------------------------------------------
	
	// 正则匹配 模式参数modle,匹配源是arr是一个数组,并把匹配的结果以一个新的数组返回
	## preg_grep(string modle,array arr);
	# 例如  $arr = array(
	#					'php',
	#					'php0',
	#					'ph',
	#					'pop'	
	#				);
	
	# print_r(preg_grep('/php/', $$arr));
	# 返回结果是
	##     array( 0 => 'php',
	#     				1 => 'php0'
	#       );
	
	
	
	
	//正则匹配判断 preg_match < 判断字符串包含 >,
 #	包含规则的内容返回 1true 
 #[其实是成匹配的个数 ，与preg_match_all 的唯一区别就是前者只匹配一次 所以 答案要么1要么0，后者则是匹配多次则返回的是个数  ] ,
 #否则返回0false
	
	## preg_match(string modle, string str,array $arr)
	#	参数一是 匹配模式，参数二是匹配源，参数三是匹配的字符串填充到这个数组上
	# 例如 echo preg_grep('/php/', 'php.asdfephp'); 结果返回1
	# 例如 echo preg_grep('/php/', 'asdfephp'); 		结果返回1
	# 例如 echo preg_grep('/php-/', 'php.asdfephp'); 结果返回0
	
	
	
	## 正则按照正则规则，符号的进行分割字符串并 < 把分割的各个子字符串 包装到一个新的数组 >
	# 数组是索引数组
	# preg_split(string modle, string str);
	#	例如 : print_r(preg_split('/[ -=]/','sdfghj bi- ufuyfu = joigiug'));
	#		返回结果
	#		Array(
  #  [0] => sdfghj
  #  [1] => bi
  #  [2] => ufuyf
  #  [3] => joigiug );
  ## 